#!/usr/bin/env python
# coding: utf-8

# In[2]:


import pandas as pd


# In[5]:


#pandas에서 데이터를 생성하는 가장 기본적인 방법은 Series()를 이용하는 것
#pandas 패키지는 데이터 분석을 할 때 가장 많이 쓰이는 패키지다.
#대부분의 데이터는 시계열(Series)이나 표의 형태로 나타낼 수 있는데 판다스 패키지에서는 이러한 표 데이터를 다루기 위한 시리즈 클래스와
#데이터프레임 클래스를 제공한다.


# In[ ]:


#시리즈 클래스


# In[7]:


#시리즈 클래스는 Numpy에서 제공하는 1차원 배열과 비슷하지만 각 데이터의 의미를 표시하는 인덱스를 붙일 수 있다.
#데이터 자체는 값(value)이라고 한다.
#시리즈 = 값 + 인덱스 ( 교재 p237)


# In[8]:


s1=pd.Series([10,20,30,40,50])


# In[13]:


s1.index


# In[11]:


s1.values


# In[14]:


#Numpy의 경우 배열의 모든 원소의 데이터 타입이 같아야 하지만, Pandas의 경우에는 원소의 데이터 타입이 달라도 무방.


# In[15]:


pd.Series(['a','b','c',1,2,3])


# In[16]:


import numpy as np


# In[18]:

 
np.nan


# In[19]:


#help(np.nan) # 시리즈를 이용하여 특정 원소가 없음을 표시


# In[20]:


pd.Series([np.nan,10,30])


# In[21]:


s1=pd.Series([1,2,3,4,5])
s2=pd.Series([10,20,30,40,50])
s1+s2


# In[22]:


type(s1+s2)


# In[23]:


s3=pd.Series([1,2,3,4,])
s4=pd.Series([10,20,30,40,50])
s3+s4


# In[25]:


# 시리즈 생성
# 데이터를 리스트나 1차원 배열 형식으로 시리즈 클래스 생성자에 넣어주면 시리즈 클래스 객체를 만들 수 있다.
# 인덱스의 길이는 데이터의 길이와 같아야 한다. 다음 예에서 이 "서울", "부산" 등의 문자열이 인덱스의 길이다.
# 인덱스의 값을 인덱스 라벨이라고도 한다. 인덱스 라벨은 무자열뿐 아니라 날짜, 시간, 정수도 가능하다.

# 다음 예제는 각 도시의 2015년 인구 데이터 시리즈로 만든 것이다.


# In[26]:


import pandas as pd


# In[27]:


s=pd.Series([9904312,3348737,2890451,2466052],index=["서울","부산","인천","대구"])


# In[28]:


s.index


# In[29]:


s.values


# In[30]:


s


# In[31]:


type(s)


# In[32]:


s.name="인구"


# In[33]:


s


# In[36]:


# 시리즈 인덱싱
# 시리즈는 넘피 배열에서 가능한 인덱스 방법 이외에도 인덱스 라벨을 이용한 인덱싱도 할 수 있다.
# 배열 인덱싱이나 인덱스 라벨을 이용한 슬라이싱도 가능하다


# In[37]:


s[0]


# In[40]:


s['부산']


# In[43]:


s[['서울','대구','부산']]


# In[44]:


s[[0,3,1]]


# In[50]:


[(2500000<= s) & (s <=5000000)]


# In[51]:


s[(2500000<= s) & (s <=5000000)]


# In[52]:


# 문자열 라벨을 이용한 슬라이싱을 하는 경우에는 콜론(;) 기호 뒤에 오는 인덱스에 해당하는 값도 결과에 포함되므로 주의해야 한다.


# In[53]:


print(s)
print(s[1:3])


# In[54]:


print(s['부산':'대구'])


# In[55]:


# 만약 라벨 값이 영문 문자열인 경우에는 마치 속성인 것처럼 점(.)을 이용하여 접근할 수도 있다.


# In[56]:


ss=pd.Series(range(3),index=['a','b','c'])


# In[57]:


ss


# In[58]:


ss.a


# In[59]:


"서울" in s


# In[60]:


# 시리즈와 딕셔너리 자료형
# 시리즈 객체는 라벨 값에 의해 인덱싱이 가능하므로 실질적으로 라벨 값을 키(key)로 가지는 딕셔너리 자료형과 같다고 볼 수 있다.
# 따라서 딕셔너리 자료형에서 제공하는 in 연산도 가능하고 items 메쏘드를 사용하면 for 루프를 통해 각 원소의 키(key)와 값(value)에 접근할 수 있다.


# In[61]:


type(s)


# In[62]:


s.items()


# In[66]:


for k, v in s.items():
    print("%s=%d"%(k,v))


# In[67]:


enumerate(['body','foo','bar'])


# In[68]:


en=enumerate(['body','foo','bar'])


# In[69]:


type(en)


# In[71]:


for k,v in en:
    print(k,v)


# In[72]:


s


# In[73]:


# 또 딕셔너리 객체에서 시리즈를 만들 수 있다.
# 이번에는 2010년 인구 자료를 s2라는 이름의 시리즈로 만들어 보자.
# 이 데이터에는 대구의 인구 자료는 없지만 대전의 인구자료가 포함되어 있다.


# In[82]:


s2=pd.Series({'서울':9631482,'부산':3393191,'인천':2632035,'대전':1490158}) # 데이터 타입: 시리즈


# In[78]:


dic1={'서울':9631482,'부산':3393191,'인천':2632035,'대전':1490158}


# In[79]:


#dic1[0]


# In[80]:


# 딕셔너리의 원소는 순서를 가지지 않으므로 시리즈의 데이터도 순서가 보장되지 않는다.


# In[81]:


s2


# In[88]:


s2=pd.Series({'서울':9631482,'부산':3393191,'인천':2632035,'대전':1490158},index=['부산','서울','인천','대전'])


# In[89]:


s2


# In[90]:


# 임의로 두 개의 시리즈 객체를 만든다. 모두 문자열 인덱스를 가져야 하며 두 시리즈에 공통적으로 포함되지 않는 라벨이 있어야 한다.
# 위에서 만든 두 시리즈 객체를 이용하여 사칙 연산을 한다.


# In[92]:


a1=pd.Series([3,4,5],index=["동물","과일","생선"])
a2=pd.Series([1,2,3],index=["야채","과일","생선"])


# In[93]:


a1+a2


# In[ ]:




